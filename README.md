# Практическое задание #2. ОБЯЗАТЕЛЬНОЕ.

Нужно реализовать параллельный bfs. От Вас требуется написать последовательную версию алгоритма  (seq) и параллельную версию (par). Протестировать надо на кубическом графе со стороной 500 и источником в (0, 0, 0). (Усреднить по 5 запускам) Сравнить время работы par на 4 процессах и seq на одном процессе - у Вас должно быть раза в 3 быстрее.  (Если будет медленнее, то выставление баллов оставляется на моё усмотрение.) Учтите, что Ваш bfs должен работать на любом графе, если Вам дан его список смежности.

Усредненные результаты (в миллисекундах):
* Sequential algorithm time is `29.8 s`
* Parallel algorithm (blockSize = N / 4) time is `13.3 s`
* Parallel algorithm (blockSize = N / 8) time is `11.7 s`
* Parallel algorithm (blockSize = N / 16) time is `11.4 s`
* Parallel algorithm (blockSize = N / 32) time is `11.1 s`
* Parallel algorithm (blockSize = N / 64) time is `11.3 s`
* Parallel algorithm (blockSize = N / 128) time is `11.4 s`
* Parallel algorithm (blockSize = N / 256) time is `11.6 s`

Ускорение в лушем случае составило `2.674`, что очень плохо.

Совершенно не понимаю, почему не получается достич лучших результатов при том, что реализован алгоритм с лекции.

Для оптимизации я написал свой оптимальный parallel filter, который дает немного лучший результат.
Конечно же все функции реализованы как блочные, причем идет разбиение на блоки размера N / const (где const = Omega(P)). 
Так же пробовал использовать просто последовательный фильтр, но он хороших результатов не дает. 
Также пробовал экономить на выделдении памяти, переиспользую некоторые массивы, но это не дало хорошего результата.
